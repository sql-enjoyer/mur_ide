### Поиск контура по цвету
```python
def find_contours(image, color):
    img_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    img_mask = cv2.inRange(img_hsv, color[0], color[1])
    cnts, hierarchy = cv2.findContours(img_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)[-2:]
    return cnts, hierarchy
```
Входные данные: изображение для поиска, цвет для поиска
Выходные данные: контуры, иерархия контуров ( используется очень редко )


```python
def find_inner_corner(image, color):
    all_contours = []
    cnts, hierarchy = find_contours(image, color)
    try:
        hierarchy = hierarchy[0]
        
        for component in zip(cnts, hierarchy):
            currentContour = component[0]
            currentHierarchy = component[1]
            x,y,w,h = cv2.boundingRect(currentContour)
            if currentHierarchy[2] < 0:
                all_contours.append(currentContour)
                
        return all_contours
            
    except TypeError:
        return []
```
Входные данные: изображение для поиска, цвет для поиска
Выходные данные: нужные контуры

### Поиск фигуры
```python
def detect_shape(drawing, cnt):
    global font
    area = cv2.contourArea(cnt)
    if area < 300:
        return "", 0, 0, 0
    
    # описанная окружность
    (circle_x, circle_y), circle_radius = cv2.minEnclosingCircle(cnt)
    circle_area = circle_radius ** 2 * math.pi
    
    # описанный прямоугольник (с вращением)
    rectangle = cv2.minAreaRect(cnt)
    # получение контура описанного прямоугольника
    box = cv2.boxPoints(rectangle)
    box = np.intp(box)
    # вычисление площади и соотношения сторон прямоугольника
    rectangle_area = cv2.contourArea(box)
    rect_w, rect_h = rectangle[1][0], rectangle[1][1]
    aspect_ratio = max(rect_w, rect_h) / min(rect_w, rect_h)
    
    # описанный треугольник
    try:
        triangle = cv2.minEnclosingTriangle(cnt)[1]
        triangle = np.intp(triangle)
        triangle_area = cv2.contourArea(triangle)
    except:
        triangle_area = 0
        
    # заполнение словаря, который будет содержать площади каждой из описанных фигур
    shapes_areas = {
        'circle': circle_area,
        'square' if aspect_ratio < 1.25 else 'rectangle': rectangle_area,         
        'triangle': triangle_area,
    }
    
    # заполнение аналогичного словаря, который будет содержать
    # разницу между площадью контора и площадью каждой из фигур
    diffs = {
        name: abs(area - shapes_areas[name]) for name in shapes_areas
    }
    
    # получение имени фигуры с наименьшей разницой площади
    shape_name = min(diffs, key=diffs.get)
    
    # поиск координат x, y для написания текста
    moments = cv2.moments(cnt)
    try:
        x = int(moments['m10'] / moments['m00'])
        y = int(moments['m01'] / moments['m00'])
            
        cv2.putText(drawing, shape_name, (x-30, y+32), font, 1, (  0,  0,  0), 3, cv2.LINE_AA)
        cv2.putText(drawing, shape_name, (x-31, y+31), font, 1, (255,255,255), 1, cv2.LINE_AA)
        
        return shape_name, x, y, area
    except ZeroDivisionError:
        pass
    return shape_name, 0, 0, 0
```
Может найти треугольник, прямоугольник, квадрат и круг.
Входные данные: изображение для отрисовки, контуры фигур
Выходные данные: название фигуры, x_центра, y_центра, площадь фигуры

### Прохождение через фигуру
```python
def go_to_shape(x, y, area):
    # разрешение нижней камеры 240 на 320
    x_center = x - (320 / 2)
    y_center = y - (240 / 2)

    try:
        # если расстояние от центра камеры до корзины подходящее,
        # то возврашается True
        length = math.sqrt(x_center ** 2 + y_center ** 2)

        if length < 10.0:
            auv.set_motor_power(0, 15)
            auv.set_motor_power(1, 15)
            auv.set_motor_power(2, 0)
            auv.set_motor_power(3, 0)
            auv.set_motor_power(4, 0)
            if area > 5000:
                return True
        else:
            # корректировка положения кад корзиной
            output_vertical = go_to_shape.regulator_vertical.process(y_center)
            output_side = go_to_shape.regulator_side.process(x_center)
    
            output_vertical = clamp(output_vertical, 50, -50)
            output_side = clamp(output_side, 50, -50)
    
		    # auv.set_motor_power(0, 0)
		    # auv.set_motor_power(1, 0)
            auv.set_motor_power(2, -output_vertical)
            auv.set_motor_power(3, -output_vertical)
            auv.set_motor_power(4, -output_side)
    except AttributeError:
        go_to_shape.regulator_vertical = PD()
        go_to_shape.regulator_vertical.set_p_gain(0.2)
        go_to_shape.regulator_vertical.set_d_gain(0.4)
        go_to_shape.regulator_side = PD()
        go_to_shape.regulator_side.set_p_gain(0.2)
        go_to_shape.regulator_side.set_d_gain(0.4)

    except ZeroDivisionError:
        return False
```
Входные данные: x_центра, y_центра, площадь фигуры
Выходные данные: False ( только при неполадке )

